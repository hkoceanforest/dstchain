// Code generated by protoc-gen-gogo. DO NOT EDIT.

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	io "io"
	math "math"
	math_bits "math/bits"
)

var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

const _ = proto.GoGoProtoPackageIsVersion3 

type GenesisState struct {
	
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	
	Clusters []DeviceClusterExport `protobuf:"bytes,2,rep,name=clusters,proto3" json:"clusters"`
	
	PersonalClusters []PersonalClusterInfoExport `protobuf:"bytes,3,rep,name=personal_clusters,json=personalClusters,proto3" json:"personal_clusters"`
	
	ClusterChatIdReflection []ClusterChatId2ClusterId `protobuf:"bytes,4,rep,name=cluster_chat_id_reflection,json=clusterChatIdReflection,proto3" json:"cluster_chat_id_reflection"`
	
	GatewayCluster string `protobuf:"bytes,5,opt,name=gateway_cluster,json=gatewayCluster,proto3" json:"gateway_cluster,omitempty"`
	
	ClusterStrategyAddress []ClusterStrategyAddress `protobuf:"bytes,6,rep,name=cluster_strategy_address,json=clusterStrategyAddress,proto3" json:"cluster_strategy_address"`
	
	ClusterCreateTime []ClusterCreateTimeExport `protobuf:"bytes,7,rep,name=cluster_create_time,json=clusterCreateTime,proto3" json:"cluster_create_time"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{0}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetClusters() []DeviceClusterExport {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *GenesisState) GetPersonalClusters() []PersonalClusterInfoExport {
	if m != nil {
		return m.PersonalClusters
	}
	return nil
}

func (m *GenesisState) GetClusterChatIdReflection() []ClusterChatId2ClusterId {
	if m != nil {
		return m.ClusterChatIdReflection
	}
	return nil
}

func (m *GenesisState) GetGatewayCluster() string {
	if m != nil {
		return m.GatewayCluster
	}
	return ""
}

func (m *GenesisState) GetClusterStrategyAddress() []ClusterStrategyAddress {
	if m != nil {
		return m.ClusterStrategyAddress
	}
	return nil
}

func (m *GenesisState) GetClusterCreateTime() []ClusterCreateTimeExport {
	if m != nil {
		return m.ClusterCreateTime
	}
	return nil
}

type DeviceClusterExport struct {
	ClusterId                      string                                 `protobuf:"bytes,1,opt,name=ClusterId,proto3" json:"ClusterId,omitempty"`
	ClusterChatId                  string                                 `protobuf:"bytes,2,opt,name=ClusterChatId,proto3" json:"ClusterChatId,omitempty"`
	ClusterName                    string                                 `protobuf:"bytes,3,opt,name=ClusterName,proto3" json:"ClusterName,omitempty"`
	ClusterOwner                   string                                 `protobuf:"bytes,4,opt,name=ClusterOwner,proto3" json:"ClusterOwner,omitempty"`
	ClusterGateway                 string                                 `protobuf:"bytes,5,opt,name=ClusterGateway,proto3" json:"ClusterGateway,omitempty"`
	ClusterLeader                  string                                 `protobuf:"bytes,6,opt,name=ClusterLeader,proto3" json:"ClusterLeader,omitempty"`
	ClusterDeviceMembers           map[string]ClusterDeviceMemberExport   `protobuf:"bytes,7,rep,name=ClusterDeviceMembers,proto3" json:"ClusterDeviceMembers" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ClusterPowerMembers            map[string]ClusterPowerMemberExport    `protobuf:"bytes,8,rep,name=ClusterPowerMembers,proto3" json:"ClusterPowerMembers" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ClusterPower                   github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=ClusterPower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ClusterPower" yaml:"cluster_power"`
	ClusterLevel                   int64                                  `protobuf:"varint,10,opt,name=ClusterLevel,proto3" json:"ClusterLevel,omitempty"`
	ClusterBurnAmount              github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=ClusterBurnAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ClusterBurnAmount" yaml:"cluster_burn_amount"`
	ClusterActiveDevice            int64                                  `protobuf:"varint,12,opt,name=ClusterActiveDevice,proto3" json:"ClusterActiveDevice,omitempty"`
	ClusterDaoPool                 string                                 `protobuf:"bytes,13,opt,name=ClusterDaoPool,proto3" json:"ClusterDaoPool,omitempty"`
	ClusterRouteRewardPool         string                                 `protobuf:"bytes,14,opt,name=ClusterRouteRewardPool,proto3" json:"ClusterRouteRewardPool,omitempty"`
	ClusterDeviceRatio             github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,15,opt,name=ClusterDeviceRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ClusterDeviceRatio" yaml:"cluster_device_ratio"`
	ClusterDeviceRatioUpdateHeight int64                                  `protobuf:"varint,16,opt,name=ClusterDeviceRatioUpdateHeight,proto3" json:"ClusterDeviceRatioUpdateHeight,omitempty"`
	ClusterSalaryRatio             github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,17,opt,name=ClusterSalaryRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ClusterSalaryRatio" yaml:"cluster_salary_ratio"`
	ClusterSalaryRatioUpdateHeight ClusterChangeRatioHeightExport         `protobuf:"bytes,18,opt,name=ClusterSalaryRatioUpdateHeight,proto3" json:"ClusterSalaryRatioUpdateHeight"`
	ClusterDvmRatio                github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,19,opt,name=ClusterDvmRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ClusterDvmRatio" yaml:"cluster_dvm_ratio"`
	ClusterDaoRatio                github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,20,opt,name=ClusterDaoRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ClusterDaoRatio" yaml:"cluster_dao_ratio"`
	OnlineRatio                    github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,21,opt,name=OnlineRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"OnlineRatio" yaml:"online_ratio"`
	OnlineRatioUpdateTime          int64                                  `protobuf:"varint,22,opt,name=OnlineRatioUpdateTime,proto3" json:"OnlineRatioUpdateTime,omitempty"`
	ClusterAdminList               string                                 `protobuf:"bytes,23,opt,name=ClusterAdminList,proto3" json:"ClusterAdminList,omitempty"`
	ClusterVoteId                  uint64                                 `protobuf:"varint,24,opt,name=ClusterVoteId,proto3" json:"ClusterVoteId,omitempty"`
	ClusterVotePolicy              string                                 `protobuf:"bytes,25,opt,name=ClusterVotePolicy,proto3" json:"ClusterVotePolicy,omitempty"`
}

func (m *DeviceClusterExport) Reset()         { *m = DeviceClusterExport{} }
func (m *DeviceClusterExport) String() string { return proto.CompactTextString(m) }
func (*DeviceClusterExport) ProtoMessage()    {}
func (*DeviceClusterExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{1}
}
func (m *DeviceClusterExport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceClusterExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceClusterExport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceClusterExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceClusterExport.Merge(m, src)
}
func (m *DeviceClusterExport) XXX_Size() int {
	return m.Size()
}
func (m *DeviceClusterExport) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceClusterExport.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceClusterExport proto.InternalMessageInfo

func (m *DeviceClusterExport) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterChatId() string {
	if m != nil {
		return m.ClusterChatId
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterOwner() string {
	if m != nil {
		return m.ClusterOwner
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterGateway() string {
	if m != nil {
		return m.ClusterGateway
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterLeader() string {
	if m != nil {
		return m.ClusterLeader
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterDeviceMembers() map[string]ClusterDeviceMemberExport {
	if m != nil {
		return m.ClusterDeviceMembers
	}
	return nil
}

func (m *DeviceClusterExport) GetClusterPowerMembers() map[string]ClusterPowerMemberExport {
	if m != nil {
		return m.ClusterPowerMembers
	}
	return nil
}

func (m *DeviceClusterExport) GetClusterLevel() int64 {
	if m != nil {
		return m.ClusterLevel
	}
	return 0
}

func (m *DeviceClusterExport) GetClusterActiveDevice() int64 {
	if m != nil {
		return m.ClusterActiveDevice
	}
	return 0
}

func (m *DeviceClusterExport) GetClusterDaoPool() string {
	if m != nil {
		return m.ClusterDaoPool
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterRouteRewardPool() string {
	if m != nil {
		return m.ClusterRouteRewardPool
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterDeviceRatioUpdateHeight() int64 {
	if m != nil {
		return m.ClusterDeviceRatioUpdateHeight
	}
	return 0
}

func (m *DeviceClusterExport) GetClusterSalaryRatioUpdateHeight() ClusterChangeRatioHeightExport {
	if m != nil {
		return m.ClusterSalaryRatioUpdateHeight
	}
	return ClusterChangeRatioHeightExport{}
}

func (m *DeviceClusterExport) GetOnlineRatioUpdateTime() int64 {
	if m != nil {
		return m.OnlineRatioUpdateTime
	}
	return 0
}

func (m *DeviceClusterExport) GetClusterAdminList() string {
	if m != nil {
		return m.ClusterAdminList
	}
	return ""
}

func (m *DeviceClusterExport) GetClusterVoteId() uint64 {
	if m != nil {
		return m.ClusterVoteId
	}
	return 0
}

func (m *DeviceClusterExport) GetClusterVotePolicy() string {
	if m != nil {
		return m.ClusterVotePolicy
	}
	return ""
}

type ClusterDeviceMemberExport struct {
	Address     string                                 `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	ActivePower github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=ActivePower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ActivePower" yaml:"active_power"`
}

func (m *ClusterDeviceMemberExport) Reset()         { *m = ClusterDeviceMemberExport{} }
func (m *ClusterDeviceMemberExport) String() string { return proto.CompactTextString(m) }
func (*ClusterDeviceMemberExport) ProtoMessage()    {}
func (*ClusterDeviceMemberExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{2}
}
func (m *ClusterDeviceMemberExport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterDeviceMemberExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterDeviceMemberExport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterDeviceMemberExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterDeviceMemberExport.Merge(m, src)
}
func (m *ClusterDeviceMemberExport) XXX_Size() int {
	return m.Size()
}
func (m *ClusterDeviceMemberExport) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterDeviceMemberExport.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterDeviceMemberExport proto.InternalMessageInfo

func (m *ClusterDeviceMemberExport) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ClusterPowerMemberExport struct {
	Address            string                                 `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	ActivePower        github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=ActivePower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ActivePower" yaml:"active_power"`
	BurnAmount         github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=BurnAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"BurnAmount" yaml:"burn_amount"`
	PowerCanReceiveDao github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=PowerCanReceiveDao,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"PowerCanReceiveDao" yaml:"power_can_receive_dao"`
}

func (m *ClusterPowerMemberExport) Reset()         { *m = ClusterPowerMemberExport{} }
func (m *ClusterPowerMemberExport) String() string { return proto.CompactTextString(m) }
func (*ClusterPowerMemberExport) ProtoMessage()    {}
func (*ClusterPowerMemberExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{3}
}
func (m *ClusterPowerMemberExport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterPowerMemberExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterPowerMemberExport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterPowerMemberExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterPowerMemberExport.Merge(m, src)
}
func (m *ClusterPowerMemberExport) XXX_Size() int {
	return m.Size()
}
func (m *ClusterPowerMemberExport) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterPowerMemberExport.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterPowerMemberExport proto.InternalMessageInfo

func (m *ClusterPowerMemberExport) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ClusterChangeRatioHeightExport struct {
	SalaryRatioUpdateHeight int64 `protobuf:"varint,1,opt,name=SalaryRatioUpdateHeight,proto3" json:"SalaryRatioUpdateHeight,omitempty"`
	DvmRatioUpdateHeight    int64 `protobuf:"varint,2,opt,name=DvmRatioUpdateHeight,proto3" json:"DvmRatioUpdateHeight,omitempty"`
	DaoRatioUpdateHeight    int64 `protobuf:"varint,3,opt,name=DaoRatioUpdateHeight,proto3" json:"DaoRatioUpdateHeight,omitempty"`
}

func (m *ClusterChangeRatioHeightExport) Reset()         { *m = ClusterChangeRatioHeightExport{} }
func (m *ClusterChangeRatioHeightExport) String() string { return proto.CompactTextString(m) }
func (*ClusterChangeRatioHeightExport) ProtoMessage()    {}
func (*ClusterChangeRatioHeightExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{4}
}
func (m *ClusterChangeRatioHeightExport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterChangeRatioHeightExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterChangeRatioHeightExport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterChangeRatioHeightExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterChangeRatioHeightExport.Merge(m, src)
}
func (m *ClusterChangeRatioHeightExport) XXX_Size() int {
	return m.Size()
}
func (m *ClusterChangeRatioHeightExport) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterChangeRatioHeightExport.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterChangeRatioHeightExport proto.InternalMessageInfo

func (m *ClusterChangeRatioHeightExport) GetSalaryRatioUpdateHeight() int64 {
	if m != nil {
		return m.SalaryRatioUpdateHeight
	}
	return 0
}

func (m *ClusterChangeRatioHeightExport) GetDvmRatioUpdateHeight() int64 {
	if m != nil {
		return m.DvmRatioUpdateHeight
	}
	return 0
}

func (m *ClusterChangeRatioHeightExport) GetDaoRatioUpdateHeight() int64 {
	if m != nil {
		return m.DaoRatioUpdateHeight
	}
	return 0
}

type PersonalClusterInfoExport struct {
	Address           string                                 `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Device            string                                 `protobuf:"bytes,2,opt,name=Device,proto3" json:"Device,omitempty"`
	Owner             string                                 `protobuf:"bytes,3,opt,name=Owner,proto3" json:"Owner,omitempty"`
	BePower           string                                 `protobuf:"bytes,4,opt,name=BePower,proto3" json:"BePower,omitempty"`
	AllBurn           github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=AllBurn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"AllBurn" yaml:"all_burn"`
	ActivePower       github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=ActivePower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"ActivePower" yaml:"active_power"`
	FreezePower       github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=FreezePower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"FreezePower" yaml:"freeze_power"`
	FirstPowerCluster string                                 `protobuf:"bytes,8,opt,name=FirstPowerCluster,proto3" json:"FirstPowerCluster,omitempty"`
}

func (m *PersonalClusterInfoExport) Reset()         { *m = PersonalClusterInfoExport{} }
func (m *PersonalClusterInfoExport) String() string { return proto.CompactTextString(m) }
func (*PersonalClusterInfoExport) ProtoMessage()    {}
func (*PersonalClusterInfoExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{5}
}
func (m *PersonalClusterInfoExport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PersonalClusterInfoExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PersonalClusterInfoExport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PersonalClusterInfoExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PersonalClusterInfoExport.Merge(m, src)
}
func (m *PersonalClusterInfoExport) XXX_Size() int {
	return m.Size()
}
func (m *PersonalClusterInfoExport) XXX_DiscardUnknown() {
	xxx_messageInfo_PersonalClusterInfoExport.DiscardUnknown(m)
}

var xxx_messageInfo_PersonalClusterInfoExport proto.InternalMessageInfo

func (m *PersonalClusterInfoExport) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *PersonalClusterInfoExport) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *PersonalClusterInfoExport) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *PersonalClusterInfoExport) GetBePower() string {
	if m != nil {
		return m.BePower
	}
	return ""
}

func (m *PersonalClusterInfoExport) GetFirstPowerCluster() string {
	if m != nil {
		return m.FirstPowerCluster
	}
	return ""
}

type ClusterChatId2ClusterId struct {
	ClusterChatId string `protobuf:"bytes,1,opt,name=ClusterChatId,proto3" json:"ClusterChatId,omitempty"`
	ClusterId     string `protobuf:"bytes,2,opt,name=ClusterId,proto3" json:"ClusterId,omitempty"`
}

func (m *ClusterChatId2ClusterId) Reset()         { *m = ClusterChatId2ClusterId{} }
func (m *ClusterChatId2ClusterId) String() string { return proto.CompactTextString(m) }
func (*ClusterChatId2ClusterId) ProtoMessage()    {}
func (*ClusterChatId2ClusterId) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{6}
}
func (m *ClusterChatId2ClusterId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterChatId2ClusterId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterChatId2ClusterId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterChatId2ClusterId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterChatId2ClusterId.Merge(m, src)
}
func (m *ClusterChatId2ClusterId) XXX_Size() int {
	return m.Size()
}
func (m *ClusterChatId2ClusterId) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterChatId2ClusterId.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterChatId2ClusterId proto.InternalMessageInfo

func (m *ClusterChatId2ClusterId) GetClusterChatId() string {
	if m != nil {
		return m.ClusterChatId
	}
	return ""
}

func (m *ClusterChatId2ClusterId) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}


type ClusterStrategyAddress struct {
	ClusterId       string `protobuf:"bytes,1,opt,name=ClusterId,proto3" json:"ClusterId,omitempty"`
	StrategyAddress string `protobuf:"bytes,2,opt,name=StrategyAddress,proto3" json:"StrategyAddress,omitempty"`
}

func (m *ClusterStrategyAddress) Reset()         { *m = ClusterStrategyAddress{} }
func (m *ClusterStrategyAddress) String() string { return proto.CompactTextString(m) }
func (*ClusterStrategyAddress) ProtoMessage()    {}
func (*ClusterStrategyAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{7}
}
func (m *ClusterStrategyAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterStrategyAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterStrategyAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterStrategyAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterStrategyAddress.Merge(m, src)
}
func (m *ClusterStrategyAddress) XXX_Size() int {
	return m.Size()
}
func (m *ClusterStrategyAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterStrategyAddress.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterStrategyAddress proto.InternalMessageInfo

func (m *ClusterStrategyAddress) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ClusterStrategyAddress) GetStrategyAddress() string {
	if m != nil {
		return m.StrategyAddress
	}
	return ""
}


type ClusterCreateTimeExport struct {
	ClusterId  string `protobuf:"bytes,1,opt,name=ClusterId,proto3" json:"ClusterId,omitempty"`
	CreateTime int64  `protobuf:"varint,2,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
}

func (m *ClusterCreateTimeExport) Reset()         { *m = ClusterCreateTimeExport{} }
func (m *ClusterCreateTimeExport) String() string { return proto.CompactTextString(m) }
func (*ClusterCreateTimeExport) ProtoMessage()    {}
func (*ClusterCreateTimeExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_14205810582f3203, []int{8}
}
func (m *ClusterCreateTimeExport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterCreateTimeExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterCreateTimeExport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterCreateTimeExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterCreateTimeExport.Merge(m, src)
}
func (m *ClusterCreateTimeExport) XXX_Size() int {
	return m.Size()
}
func (m *ClusterCreateTimeExport) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterCreateTimeExport.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterCreateTimeExport proto.InternalMessageInfo

func (m *ClusterCreateTimeExport) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ClusterCreateTimeExport) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func init() {
	proto.RegisterType((*GenesisState)(nil), "freemasonry.dao.v1.GenesisState")
	proto.RegisterType((*DeviceClusterExport)(nil), "freemasonry.dao.v1.DeviceClusterExport")
	proto.RegisterMapType((map[string]ClusterDeviceMemberExport)(nil), "freemasonry.dao.v1.DeviceClusterExport.ClusterDeviceMembersEntry")
	proto.RegisterMapType((map[string]ClusterPowerMemberExport)(nil), "freemasonry.dao.v1.DeviceClusterExport.ClusterPowerMembersEntry")
	proto.RegisterType((*ClusterDeviceMemberExport)(nil), "freemasonry.dao.v1.ClusterDeviceMemberExport")
	proto.RegisterType((*ClusterPowerMemberExport)(nil), "freemasonry.dao.v1.ClusterPowerMemberExport")
	proto.RegisterType((*ClusterChangeRatioHeightExport)(nil), "freemasonry.dao.v1.ClusterChangeRatioHeightExport")
	proto.RegisterType((*PersonalClusterInfoExport)(nil), "freemasonry.dao.v1.PersonalClusterInfoExport")
	proto.RegisterType((*ClusterChatId2ClusterId)(nil), "freemasonry.dao.v1.ClusterChatId2ClusterId")
	proto.RegisterType((*ClusterStrategyAddress)(nil), "freemasonry.dao.v1.ClusterStrategyAddress")
	proto.RegisterType((*ClusterCreateTimeExport)(nil), "freemasonry.dao.v1.ClusterCreateTimeExport")
}

func init() { proto.RegisterFile("genesis.proto", fileDescriptor_14205810582f3203) }

var fileDescriptor_14205810582f3203 = []byte{
	
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xda, 0xa9, 0xd3, 0x8c, 0xdb, 0xfc, 0x8c, 0xdd, 0x64, 0x62, 0x22, 0xc7, 0x5a, 0x41,
	0x6b, 0x95, 0xd6, 0xa6, 0x01, 0xa1, 0xa8, 0x37, 0x60, 0xe7, 0xa7, 0x04, 0xa5, 0x6d, 0xb4, 0xe1,
	0x47, 0x02, 0x21, 0x77, 0xb2, 0x3b, 0xd9, 0x6c, 0xb3, 0xbb, 0x63, 0xcd, 0x8e, 0x9d, 0xb8, 0x08,
	0x84, 0xc4, 0x0b, 0xf0, 0x04, 0x3c, 0x0c, 0xe2, 0xa2, 0x97, 0xbd, 0x44, 0x95, 0x88, 0x50, 0xf2,
	0x06, 0x3c, 0x01, 0xda, 0x99, 0x59, 0x67, 0xd7, 0x5e, 0x27, 0x58, 0x2d, 0x12, 0x57, 0xf1, 0x9c,
	0x39, 0xe7, 0xfb, 0xce, 0x39, 0x73, 0x76, 0xce, 0x99, 0x80, 0x9b, 0x36, 0xf1, 0x49, 0xe0, 0x04,
	0xb5, 0x36, 0xa3, 0x9c, 0x42, 0x78, 0xc0, 0x08, 0xf1, 0x70, 0x40, 0x7d, 0xd6, 0xab, 0x59, 0x98,
	0xd6, 0xba, 0x0f, 0x4a, 0xcb, 0x36, 0xa5, 0xb6, 0x4b, 0xea, 0xb8, 0xed, 0xd4, 0xb1, 0xef, 0x53,
	0x8e, 0xb9, 0x43, 0x7d, 0x65, 0x51, 0x2a, 0xda, 0xd4, 0xa6, 0xe2, 0x67, 0x3d, 0xfc, 0xa5, 0xa4,
	0x05, 0x0b, 0xd3, 0x7a, 0xf7, 0x41, 0xbd, 0x8d, 0x19, 0xf6, 0x94, 0xaa, 0xfe, 0xe7, 0x24, 0xb8,
	0xf1, 0x48, 0xd2, 0xed, 0x71, 0xcc, 0x09, 0x5c, 0x03, 0x39, 0xa9, 0x80, 0xb4, 0x8a, 0x56, 0xcd,
	0xaf, 0x96, 0x6a, 0xc3, 0xf4, 0xb5, 0x5d, 0xa1, 0xd1, 0x9c, 0x7c, 0x79, 0xba, 0x32, 0x61, 0x28,
	0x7d, 0xb8, 0x0d, 0xae, 0x9b, 0x6e, 0x27, 0xe0, 0x84, 0x05, 0x28, 0x53, 0xc9, 0x56, 0xf3, 0xab,
	0x77, 0xd2, 0x6c, 0x37, 0x48, 0xd7, 0x31, 0xc9, 0xba, 0xd4, 0xdc, 0x3c, 0x69, 0x53, 0xc6, 0x15,
	0x50, 0xdf, 0x1c, 0x3e, 0x03, 0xf3, 0x6d, 0xc2, 0x02, 0xea, 0x63, 0xb7, 0xd5, 0xc7, 0xcc, 0x0a,
	0xcc, 0xfb, 0xa9, 0xfe, 0x28, 0x65, 0x85, 0xba, 0xed, 0x1f, 0xd0, 0x04, 0xf2, 0x5c, 0x3b, 0xa9,
	0x10, 0x40, 0x1f, 0x94, 0x14, 0x70, 0xcb, 0x3c, 0xc4, 0xbc, 0xe5, 0x58, 0x2d, 0x46, 0x0e, 0x5c,
	0x62, 0x86, 0x79, 0x44, 0x93, 0x82, 0xea, 0xfd, 0x34, 0x2a, 0x85, 0xb0, 0x7e, 0x88, 0xf9, 0xb6,
	0xb5, 0x1a, 0x11, 0x5a, 0x8a, 0x68, 0xd1, 0x8c, 0x6f, 0x1b, 0x7d, 0x44, 0x78, 0x07, 0xcc, 0xda,
	0x98, 0x93, 0x63, 0xdc, 0x8b, 0x02, 0x42, 0xd7, 0x2a, 0x5a, 0x75, 0xda, 0x98, 0x51, 0x62, 0x85,
	0x04, 0x9f, 0x03, 0x14, 0x39, 0x16, 0x70, 0x86, 0x39, 0xb1, 0x7b, 0x2d, 0x6c, 0x59, 0x8c, 0x04,
	0x01, 0xca, 0x09, 0xb7, 0xee, 0x5e, 0xe2, 0xd6, 0x9e, 0x32, 0x69, 0x48, 0x0b, 0xe5, 0xd5, 0x82,
	0x99, 0xba, 0x0b, 0x31, 0x28, 0xf4, 0x93, 0xc0, 0x08, 0xe6, 0xa4, 0xc5, 0x1d, 0x8f, 0xa0, 0xa9,
	0xab, 0xa3, 0x17, 0xda, 0x5f, 0x38, 0x1e, 0x49, 0xa4, 0x79, 0xde, 0x1c, 0xdc, 0xd6, 0x7f, 0x9f,
	0x03, 0x85, 0x94, 0x13, 0x87, 0xcb, 0x60, 0xba, 0x9f, 0x3b, 0x51, 0x69, 0xd3, 0xc6, 0x85, 0x00,
	0xbe, 0x0b, 0x6e, 0x26, 0xf2, 0x8c, 0x32, 0x42, 0x23, 0x29, 0x84, 0x15, 0x90, 0x57, 0x82, 0x27,
	0xd8, 0x23, 0x28, 0x2b, 0x74, 0xe2, 0x22, 0xa8, 0x83, 0x1b, 0x6a, 0xf9, 0xf4, 0xd8, 0x27, 0x0c,
	0x4d, 0x0a, 0x95, 0x84, 0x0c, 0xde, 0x06, 0x33, 0x6a, 0xfd, 0x48, 0x9e, 0x44, 0x74, 0x30, 0x49,
	0x69, 0xcc, 0xa7, 0x1d, 0x82, 0x2d, 0xc2, 0x50, 0x2e, 0xe1, 0x93, 0x14, 0xc2, 0xef, 0x41, 0x51,
	0x09, 0x64, 0xd4, 0x8f, 0x89, 0xb7, 0x1f, 0x16, 0xaf, 0xcc, 0x69, 0xe3, 0x5f, 0x7e, 0x10, 0xb5,
	0x34, 0x8c, 0x4d, 0x9f, 0xb3, 0x9e, 0xca, 0x74, 0x2a, 0x09, 0x3c, 0x01, 0x05, 0x25, 0xdf, 0xa5,
	0xc7, 0x84, 0x45, 0xdc, 0xd7, 0x05, 0xf7, 0xa7, 0x63, 0x72, 0xc7, 0x21, 0xe2, 0xd4, 0x69, 0x14,
	0xf0, 0x79, 0x3f, 0xd1, 0x42, 0x8c, 0xa6, 0xc3, 0xdc, 0x34, 0xb7, 0x42, 0x83, 0xd7, 0xa7, 0x2b,
	0xb7, 0x6d, 0x87, 0x1f, 0x76, 0xf6, 0x6b, 0x26, 0xf5, 0xea, 0x26, 0x0d, 0x3c, 0x1a, 0xa8, 0x3f,
	0xf7, 0x03, 0xeb, 0xa8, 0xce, 0x7b, 0x6d, 0x12, 0xd4, 0x36, 0x88, 0xf9, 0xf7, 0xe9, 0x4a, 0xb1,
	0x87, 0x3d, 0xf7, 0xa1, 0x1e, 0x55, 0x65, 0x3b, 0x04, 0xd3, 0x8d, 0x04, 0x76, 0xec, 0x50, 0x77,
	0x48, 0x97, 0xb8, 0x08, 0x54, 0xb4, 0x6a, 0xd6, 0x48, 0xc8, 0xe0, 0x0b, 0x30, 0xaf, 0xd6, 0xcd,
	0x0e, 0xf3, 0x1b, 0x1e, 0xed, 0xf8, 0x1c, 0xe5, 0x85, 0x53, 0x3b, 0x63, 0x3b, 0x55, 0x4a, 0x3a,
	0xb5, 0xdf, 0x61, 0x7e, 0x0b, 0x0b, 0x48, 0xdd, 0x18, 0xa6, 0x81, 0x1f, 0xf4, 0x4f, 0xa1, 0x61,
	0x72, 0xa7, 0x4b, 0x64, 0x8e, 0xd1, 0x0d, 0xe1, 0x66, 0xda, 0x56, 0xac, 0x04, 0x37, 0x30, 0xdd,
	0xa5, 0xd4, 0x45, 0x37, 0x13, 0x25, 0xa8, 0xa4, 0xf0, 0x63, 0xb0, 0xa0, 0x24, 0x06, 0xed, 0x70,
	0x62, 0x90, 0x63, 0xcc, 0x2c, 0xa1, 0x3f, 0x23, 0xf4, 0x47, 0xec, 0xc2, 0x1f, 0x00, 0x4c, 0xd4,
	0x8b, 0x11, 0x76, 0x0b, 0x34, 0x2b, 0xd2, 0xf1, 0x78, 0xec, 0x74, 0xbc, 0x93, 0x4c, 0x87, 0x25,
	0x20, 0x5b, 0x2c, 0xc4, 0xd4, 0x8d, 0x14, 0x22, 0xb8, 0x05, 0xca, 0xc3, 0xd2, 0x2f, 0xdb, 0x16,
	0xe6, 0xe4, 0x33, 0xe2, 0xd8, 0x87, 0x1c, 0xcd, 0x89, 0xdc, 0x5c, 0xa1, 0x15, 0x0b, 0x63, 0x0f,
	0xbb, 0x98, 0xf5, 0x64, 0x18, 0xf3, 0x6f, 0x27, 0x8c, 0x40, 0x40, 0x0e, 0x86, 0x11, 0x23, 0x82,
	0x3f, 0x69, 0xfd, 0x38, 0x62, 0xe2, 0x44, 0x1c, 0x50, 0xb4, 0xcc, 0xd5, 0xcb, 0xfb, 0x86, 0x6f,
	0xcb, 0xd8, 0xa4, 0x4d, 0xe2, 0x02, 0xbd, 0x02, 0x1f, 0x72, 0x30, 0x1b, 0xe5, 0xa8, 0xeb, 0xc9,
	0xf0, 0x0b, 0x22, 0xfc, 0xcf, 0xc7, 0x0e, 0x1f, 0x0d, 0x9c, 0x62, 0xd7, 0x8b, 0x62, 0x1f, 0xa4,
	0x88, 0xb3, 0x62, 0x2a, 0x59, 0x8b, 0x6f, 0x89, 0x15, 0xd3, 0x21, 0x56, 0x45, 0x01, 0x6d, 0x90,
	0x7f, 0xea, 0xbb, 0x8e, 0xaf, 0xaa, 0xf5, 0x96, 0x60, 0xdc, 0x1c, 0x9b, 0xb1, 0x20, 0x19, 0xa9,
	0x80, 0x8a, 0xc8, 0xe2, 0xc8, 0xf0, 0x23, 0x70, 0x2b, 0xb6, 0x94, 0xf9, 0x0e, 0x7b, 0x17, 0x5a,
	0x10, 0x55, 0x99, 0xbe, 0x09, 0xef, 0x82, 0xb9, 0xe8, 0x53, 0xb6, 0x3c, 0xc7, 0xdf, 0x71, 0x02,
	0x8e, 0x16, 0xc5, 0x57, 0x38, 0x24, 0x8f, 0xb5, 0x8e, 0xaf, 0x28, 0x27, 0xdb, 0x16, 0x42, 0x15,
	0xad, 0x3a, 0x69, 0x24, 0x85, 0xf0, 0x5e, 0xff, 0xce, 0x0a, 0x05, 0xbb, 0xd4, 0x75, 0xcc, 0x1e,
	0x5a, 0x12, 0x90, 0xc3, 0x1b, 0xa5, 0x2e, 0x58, 0x1a, 0xd9, 0x24, 0xe0, 0x1c, 0xc8, 0x1e, 0x91,
	0x9e, 0xea, 0xab, 0xe1, 0x4f, 0xb8, 0x0e, 0xae, 0x75, 0xb1, 0xdb, 0x21, 0xa2, 0x93, 0x8e, 0x98,
	0xa2, 0x52, 0xf0, 0x64, 0x75, 0x1a, 0xd2, 0xf6, 0x61, 0x66, 0x4d, 0x2b, 0x71, 0x80, 0x46, 0x35,
	0x88, 0x14, 0xda, 0x66, 0x92, 0xf6, 0xde, 0x25, 0xb4, 0x31, 0xb8, 0x21, 0x56, 0xfd, 0x57, 0x2d,
	0x35, 0x5c, 0x35, 0x4c, 0x20, 0x30, 0xa5, 0x46, 0x1a, 0xc5, 0x1d, 0x2d, 0xc3, 0x22, 0x92, 0x37,
	0xad, 0x6c, 0x4b, 0x99, 0x37, 0x2b, 0x22, 0x2c, 0xa0, 0xa2, 0xae, 0x14, 0x47, 0xd6, 0x7f, 0xce,
	0xa6, 0xe5, 0xe5, 0x7f, 0xe3, 0x1f, 0xb4, 0x00, 0x88, 0x75, 0x42, 0x31, 0x2a, 0x35, 0x37, 0xc6,
	0xe6, 0x81, 0x92, 0x27, 0xd1, 0x01, 0x63, 0xb8, 0xf0, 0x47, 0x00, 0x05, 0xdd, 0x3a, 0xf6, 0x0d,
	0x62, 0x92, 0xb0, 0xc3, 0x61, 0x2a, 0xa7, 0xae, 0xe6, 0x93, 0xb1, 0xd9, 0x96, 0x25, 0x9b, 0x08,
	0xa7, 0x65, 0x62, 0xbf, 0xc5, 0x24, 0x66, 0x78, 0x6d, 0xe8, 0x46, 0x0a, 0x93, 0xfe, 0xdb, 0xc5,
	0x15, 0x3d, 0xe2, 0xa2, 0x85, 0x6b, 0x60, 0x71, 0xd4, 0xed, 0xad, 0x89, 0xef, 0x7d, 0xd4, 0x36,
	0x5c, 0x05, 0xc5, 0xe8, 0x4a, 0x4c, 0x98, 0x65, 0x84, 0x59, 0xea, 0x9e, 0xb0, 0x51, 0x17, 0x5a,
	0xc2, 0x26, 0xab, 0x6c, 0x52, 0xf6, 0xf4, 0xd7, 0x59, 0xb0, 0x34, 0xf2, 0x41, 0x73, 0x49, 0x2d,
	0x2d, 0x80, 0x9c, 0x1a, 0x35, 0xe4, 0xb4, 0xac, 0x56, 0xb0, 0x08, 0xae, 0xc9, 0xe9, 0x57, 0x0e,
	0xc8, 0x72, 0x11, 0xe2, 0x34, 0x55, 0xd5, 0xc9, 0xa9, 0x38, 0x5a, 0xc2, 0x6f, 0xc1, 0x54, 0xc3,
	0x75, 0xc3, 0x53, 0x95, 0x93, 0x70, 0xb3, 0x31, 0xf6, 0xc9, 0xcd, 0xaa, 0x7a, 0x74, 0x5d, 0x31,
	0x2d, 0xe9, 0x46, 0x84, 0x38, 0x58, 0xf0, 0xb9, 0xff, 0xac, 0xe0, 0x6d, 0x90, 0xdf, 0x62, 0x84,
	0xbc, 0x50, 0x44, 0x53, 0x6f, 0x46, 0x74, 0x20, 0xa0, 0xfa, 0x44, 0x31, 0xe4, 0xf0, 0xda, 0xde,
	0x72, 0x58, 0xc0, 0x65, 0x39, 0xaa, 0xb7, 0xdd, 0x75, 0x79, 0x6d, 0x0f, 0x6d, 0xe8, 0xdf, 0x81,
	0xc5, 0x11, 0x2f, 0xc8, 0xe1, 0x47, 0x8f, 0x96, 0xf6, 0xe8, 0x49, 0x3c, 0x9c, 0x32, 0x03, 0x0f,
	0x27, 0xfd, 0x59, 0x7f, 0x42, 0x1c, 0x7c, 0xeb, 0x5d, 0xfe, 0xe0, 0xaa, 0x82, 0xd9, 0x01, 0x03,
	0x85, 0x3d, 0x28, 0xd6, 0xbf, 0xbe, 0x08, 0x60, 0xe0, 0x11, 0x78, 0x05, 0x45, 0x19, 0x80, 0x0b,
	0x0b, 0xf5, 0xd1, 0xc4, 0x24, 0xcd, 0x4f, 0x5e, 0x9e, 0x95, 0xb5, 0x57, 0x67, 0x65, 0xed, 0xaf,
	0xb3, 0xb2, 0xf6, 0xcb, 0x79, 0x79, 0xe2, 0xd5, 0x79, 0x79, 0xe2, 0x8f, 0xf3, 0xf2, 0xc4, 0x37,
	0xef, 0xc5, 0x9b, 0x86, 0x69, 0xd6, 0xf7, 0x5d, 0x6a, 0x1e, 0x99, 0x87, 0xd8, 0xf1, 0xeb, 0x27,
	0x75, 0x0b, 0x53, 0x79, 0x60, 0xfb, 0x39, 0xf1, 0x1f, 0x8d, 0x0f, 0xff, 0x09, 0x00, 0x00, 0xff,
	0xff, 0x69, 0x56, 0xed, 0xb1, 0x3f, 0x11, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClusterCreateTime) > 0 {
		for iNdEx := len(m.ClusterCreateTime) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterCreateTime[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ClusterStrategyAddress) > 0 {
		for iNdEx := len(m.ClusterStrategyAddress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterStrategyAddress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.GatewayCluster) > 0 {
		i -= len(m.GatewayCluster)
		copy(dAtA[i:], m.GatewayCluster)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.GatewayCluster)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterChatIdReflection) > 0 {
		for iNdEx := len(m.ClusterChatIdReflection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterChatIdReflection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PersonalClusters) > 0 {
		for iNdEx := len(m.PersonalClusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PersonalClusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DeviceClusterExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceClusterExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceClusterExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClusterVotePolicy) > 0 {
		i -= len(m.ClusterVotePolicy)
		copy(dAtA[i:], m.ClusterVotePolicy)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterVotePolicy)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.ClusterVoteId != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.ClusterVoteId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.ClusterAdminList) > 0 {
		i -= len(m.ClusterAdminList)
		copy(dAtA[i:], m.ClusterAdminList)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterAdminList)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.OnlineRatioUpdateTime != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.OnlineRatioUpdateTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	{
		size := m.OnlineRatio.Size()
		i -= size
		if _, err := m.OnlineRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	{
		size := m.ClusterDaoRatio.Size()
		i -= size
		if _, err := m.ClusterDaoRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	{
		size := m.ClusterDvmRatio.Size()
		i -= size
		if _, err := m.ClusterDvmRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	{
		size, err := m.ClusterSalaryRatioUpdateHeight.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size := m.ClusterSalaryRatio.Size()
		i -= size
		if _, err := m.ClusterSalaryRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.ClusterDeviceRatioUpdateHeight != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.ClusterDeviceRatioUpdateHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	{
		size := m.ClusterDeviceRatio.Size()
		i -= size
		if _, err := m.ClusterDeviceRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if len(m.ClusterRouteRewardPool) > 0 {
		i -= len(m.ClusterRouteRewardPool)
		copy(dAtA[i:], m.ClusterRouteRewardPool)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterRouteRewardPool)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ClusterDaoPool) > 0 {
		i -= len(m.ClusterDaoPool)
		copy(dAtA[i:], m.ClusterDaoPool)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterDaoPool)))
		i--
		dAtA[i] = 0x6a
	}
	if m.ClusterActiveDevice != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.ClusterActiveDevice))
		i--
		dAtA[i] = 0x60
	}
	{
		size := m.ClusterBurnAmount.Size()
		i -= size
		if _, err := m.ClusterBurnAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.ClusterLevel != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.ClusterLevel))
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.ClusterPower.Size()
		i -= size
		if _, err := m.ClusterPower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.ClusterPowerMembers) > 0 {
		for k := range m.ClusterPowerMembers {
			v := m.ClusterPowerMembers[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenesis(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenesis(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ClusterDeviceMembers) > 0 {
		for k := range m.ClusterDeviceMembers {
			v := m.ClusterDeviceMembers[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGenesis(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGenesis(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ClusterLeader) > 0 {
		i -= len(m.ClusterLeader)
		copy(dAtA[i:], m.ClusterLeader)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterLeader)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ClusterGateway) > 0 {
		i -= len(m.ClusterGateway)
		copy(dAtA[i:], m.ClusterGateway)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterGateway)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterOwner) > 0 {
		i -= len(m.ClusterOwner)
		copy(dAtA[i:], m.ClusterOwner)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterOwner)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterChatId) > 0 {
		i -= len(m.ClusterChatId)
		copy(dAtA[i:], m.ClusterChatId)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterChatId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterDeviceMemberExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterDeviceMemberExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterDeviceMemberExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ActivePower.Size()
		i -= size
		if _, err := m.ActivePower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterPowerMemberExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterPowerMemberExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterPowerMemberExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PowerCanReceiveDao.Size()
		i -= size
		if _, err := m.PowerCanReceiveDao.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BurnAmount.Size()
		i -= size
		if _, err := m.BurnAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.ActivePower.Size()
		i -= size
		if _, err := m.ActivePower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterChangeRatioHeightExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterChangeRatioHeightExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterChangeRatioHeightExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DaoRatioUpdateHeight != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.DaoRatioUpdateHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.DvmRatioUpdateHeight != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.DvmRatioUpdateHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.SalaryRatioUpdateHeight != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.SalaryRatioUpdateHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PersonalClusterInfoExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PersonalClusterInfoExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PersonalClusterInfoExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FirstPowerCluster) > 0 {
		i -= len(m.FirstPowerCluster)
		copy(dAtA[i:], m.FirstPowerCluster)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.FirstPowerCluster)))
		i--
		dAtA[i] = 0x42
	}
	{
		size := m.FreezePower.Size()
		i -= size
		if _, err := m.FreezePower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.ActivePower.Size()
		i -= size
		if _, err := m.ActivePower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.AllBurn.Size()
		i -= size
		if _, err := m.AllBurn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.BePower) > 0 {
		i -= len(m.BePower)
		copy(dAtA[i:], m.BePower)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.BePower)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterChatId2ClusterId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterChatId2ClusterId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterChatId2ClusterId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterChatId) > 0 {
		i -= len(m.ClusterChatId)
		copy(dAtA[i:], m.ClusterChatId)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterChatId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterStrategyAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStrategyAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterStrategyAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StrategyAddress) > 0 {
		i -= len(m.StrategyAddress)
		copy(dAtA[i:], m.StrategyAddress)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.StrategyAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterCreateTimeExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCreateTimeExport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterCreateTimeExport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreateTime != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.PersonalClusters) > 0 {
		for _, e := range m.PersonalClusters {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.ClusterChatIdReflection) > 0 {
		for _, e := range m.ClusterChatIdReflection {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	l = len(m.GatewayCluster)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if len(m.ClusterStrategyAddress) > 0 {
		for _, e := range m.ClusterStrategyAddress {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.ClusterCreateTime) > 0 {
		for _, e := range m.ClusterCreateTime {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *DeviceClusterExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ClusterChatId)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ClusterOwner)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ClusterGateway)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ClusterLeader)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if len(m.ClusterDeviceMembers) > 0 {
		for k, v := range m.ClusterDeviceMembers {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovGenesis(uint64(len(k))) + 1 + l + sovGenesis(uint64(l))
			n += mapEntrySize + 1 + sovGenesis(uint64(mapEntrySize))
		}
	}
	if len(m.ClusterPowerMembers) > 0 {
		for k, v := range m.ClusterPowerMembers {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovGenesis(uint64(len(k))) + 1 + l + sovGenesis(uint64(l))
			n += mapEntrySize + 1 + sovGenesis(uint64(mapEntrySize))
		}
	}
	l = m.ClusterPower.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.ClusterLevel != 0 {
		n += 1 + sovGenesis(uint64(m.ClusterLevel))
	}
	l = m.ClusterBurnAmount.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.ClusterActiveDevice != 0 {
		n += 1 + sovGenesis(uint64(m.ClusterActiveDevice))
	}
	l = len(m.ClusterDaoPool)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ClusterRouteRewardPool)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.ClusterDeviceRatio.Size()
	n += 1 + l + sovGenesis(uint64(l))
	if m.ClusterDeviceRatioUpdateHeight != 0 {
		n += 2 + sovGenesis(uint64(m.ClusterDeviceRatioUpdateHeight))
	}
	l = m.ClusterSalaryRatio.Size()
	n += 2 + l + sovGenesis(uint64(l))
	l = m.ClusterSalaryRatioUpdateHeight.Size()
	n += 2 + l + sovGenesis(uint64(l))
	l = m.ClusterDvmRatio.Size()
	n += 2 + l + sovGenesis(uint64(l))
	l = m.ClusterDaoRatio.Size()
	n += 2 + l + sovGenesis(uint64(l))
	l = m.OnlineRatio.Size()
	n += 2 + l + sovGenesis(uint64(l))
	if m.OnlineRatioUpdateTime != 0 {
		n += 2 + sovGenesis(uint64(m.OnlineRatioUpdateTime))
	}
	l = len(m.ClusterAdminList)
	if l > 0 {
		n += 2 + l + sovGenesis(uint64(l))
	}
	if m.ClusterVoteId != 0 {
		n += 2 + sovGenesis(uint64(m.ClusterVoteId))
	}
	l = len(m.ClusterVotePolicy)
	if l > 0 {
		n += 2 + l + sovGenesis(uint64(l))
	}
	return n
}

func (m *ClusterDeviceMemberExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.ActivePower.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *ClusterPowerMemberExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.ActivePower.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.BurnAmount.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.PowerCanReceiveDao.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *ClusterChangeRatioHeightExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SalaryRatioUpdateHeight != 0 {
		n += 1 + sovGenesis(uint64(m.SalaryRatioUpdateHeight))
	}
	if m.DvmRatioUpdateHeight != 0 {
		n += 1 + sovGenesis(uint64(m.DvmRatioUpdateHeight))
	}
	if m.DaoRatioUpdateHeight != 0 {
		n += 1 + sovGenesis(uint64(m.DaoRatioUpdateHeight))
	}
	return n
}

func (m *PersonalClusterInfoExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.BePower)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = m.AllBurn.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.ActivePower.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = m.FreezePower.Size()
	n += 1 + l + sovGenesis(uint64(l))
	l = len(m.FirstPowerCluster)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	return n
}

func (m *ClusterChatId2ClusterId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterChatId)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	return n
}

func (m *ClusterStrategyAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	l = len(m.StrategyAddress)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	return n
}

func (m *ClusterCreateTimeExport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovGenesis(uint64(m.CreateTime))
	}
	return n
}

func sovGenesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenesis(x uint64) (n int) {
	return sovGenesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, DeviceClusterExport{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonalClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersonalClusters = append(m.PersonalClusters, PersonalClusterInfoExport{})
			if err := m.PersonalClusters[len(m.PersonalClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterChatIdReflection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterChatIdReflection = append(m.ClusterChatIdReflection, ClusterChatId2ClusterId{})
			if err := m.ClusterChatIdReflection[len(m.ClusterChatIdReflection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterStrategyAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterStrategyAddress = append(m.ClusterStrategyAddress, ClusterStrategyAddress{})
			if err := m.ClusterStrategyAddress[len(m.ClusterStrategyAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterCreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterCreateTime = append(m.ClusterCreateTime, ClusterCreateTimeExport{})
			if err := m.ClusterCreateTime[len(m.ClusterCreateTime)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceClusterExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceClusterExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceClusterExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterGateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterGateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterLeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterLeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDeviceMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterDeviceMembers == nil {
				m.ClusterDeviceMembers = make(map[string]ClusterDeviceMemberExport)
			}
			var mapkey string
			mapvalue := &ClusterDeviceMemberExport{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenesis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenesis
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenesis
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGenesis
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGenesis
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ClusterDeviceMemberExport{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenesis(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenesis
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ClusterDeviceMembers[mapkey] = *mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterPowerMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterPowerMembers == nil {
				m.ClusterPowerMembers = make(map[string]ClusterPowerMemberExport)
			}
			var mapkey string
			mapvalue := &ClusterPowerMemberExport{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGenesis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGenesis
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGenesis
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGenesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGenesis
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGenesis
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ClusterPowerMemberExport{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGenesis(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGenesis
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ClusterPowerMembers[mapkey] = *mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterPower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterLevel", wireType)
			}
			m.ClusterLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterLevel |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterBurnAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterBurnAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterActiveDevice", wireType)
			}
			m.ClusterActiveDevice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterActiveDevice |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDaoPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterDaoPool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterRouteRewardPool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterRouteRewardPool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDeviceRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterDeviceRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDeviceRatioUpdateHeight", wireType)
			}
			m.ClusterDeviceRatioUpdateHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterDeviceRatioUpdateHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterSalaryRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterSalaryRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterSalaryRatioUpdateHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterSalaryRatioUpdateHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDvmRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterDvmRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterDaoRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterDaoRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OnlineRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineRatioUpdateTime", wireType)
			}
			m.OnlineRatioUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnlineRatioUpdateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterAdminList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterAdminList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterVoteId", wireType)
			}
			m.ClusterVoteId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterVoteId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterVotePolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterVotePolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterDeviceMemberExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterDeviceMemberExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterDeviceMemberExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ActivePower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterPowerMemberExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterPowerMemberExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterPowerMemberExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ActivePower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerCanReceiveDao", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PowerCanReceiveDao.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterChangeRatioHeightExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterChangeRatioHeightExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterChangeRatioHeightExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SalaryRatioUpdateHeight", wireType)
			}
			m.SalaryRatioUpdateHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SalaryRatioUpdateHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DvmRatioUpdateHeight", wireType)
			}
			m.DvmRatioUpdateHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DvmRatioUpdateHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaoRatioUpdateHeight", wireType)
			}
			m.DaoRatioUpdateHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DaoRatioUpdateHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersonalClusterInfoExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonalClusterInfoExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonalClusterInfoExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BePower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BePower = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllBurn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllBurn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivePower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ActivePower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreezePower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FreezePower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstPowerCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstPowerCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterChatId2ClusterId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterChatId2ClusterId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterChatId2ClusterId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterChatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterChatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStrategyAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStrategyAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStrategyAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrategyAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StrategyAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCreateTimeExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCreateTimeExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCreateTimeExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenesis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenesis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenesis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
